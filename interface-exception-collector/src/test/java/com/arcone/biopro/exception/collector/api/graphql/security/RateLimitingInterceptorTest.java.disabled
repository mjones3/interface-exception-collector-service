package com.arcone.biopro.exception.collector.api.graphql.security;

import graphql.execution.instrumentation.parameters.InstrumentationExecutionParameters;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.redis.core.RedisTemplate;
import org.springframework.data.redis.core.ValueOperations;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import java.util.List;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for RateLimitingInterceptor.
 */
@Disabled("Redis is disabled - rate limiting tests cannot run")
@ExtendWith(MockitoExtension.class)
class RateLimitingInterceptorTest {

    @Mock
    private RedisTemplate<String, Object> redisTemplate;

    @Mock
    private ValueOperations<String, Object> valueOperations;

    @Mock
    private RateLimitingConfig rateLimitingConfig;

    @Mock
    private Authentication authentication;

    @Mock
    private SecurityContext securityContext;

    @Mock
    private InstrumentationExecutionParameters parameters;

    private RateLimitingInterceptor rateLimitingInterceptor;

    @BeforeEach
    void setUp() {
        when(redisTemplate.opsForValue()).thenReturn(valueOperations);
        rateLimitingInterceptor = new RateLimitingInterceptor(redisTemplate, rateLimitingConfig);

        // Setup security context
        SecurityContextHolder.setContext(securityContext);
        when(securityContext.getAuthentication()).thenReturn(authentication);
        when(authentication.isAuthenticated()).thenReturn(true);
        when(authentication.getName()).thenReturn("testuser");
    }

    @Test
    void shouldAllowRequestWithinRateLimit() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_VIEWER")));
        when(rateLimitingConfig.getRateLimitForRole("VIEWER")).thenReturn(
                new RateLimitingInterceptor.RateLimit(60, 1800, 1000));
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");
        when(valueOperations.get(anyString())).thenReturn(30L); // Under limit

        // When & Then - Should not throw exception
        assertDoesNotThrow(() -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });
    }

    @Test
    void shouldThrowExceptionWhenMinuteRateLimitExceeded() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_VIEWER")));
        when(rateLimitingConfig.getRateLimitForRole("VIEWER")).thenReturn(
                new RateLimitingInterceptor.RateLimit(60, 1800, 1000));
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");
        when(valueOperations.get(anyString())).thenReturn(65L); // Over minute limit

        // When & Then
        assertThrows(RateLimitExceededException.class, () -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });
    }

    @Test
    void shouldThrowExceptionWhenHourRateLimitExceeded() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_VIEWER")));
        when(rateLimitingConfig.getRateLimitForRole("VIEWER")).thenReturn(
                new RateLimitingInterceptor.RateLimit(60, 1800, 1000));
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");
        when(valueOperations.get(anyString()))
                .thenReturn(30L) // Under minute limit
                .thenReturn(2000L); // Over hour limit

        // When & Then
        assertThrows(RateLimitExceededException.class, () -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });
    }

    @Test
    void shouldThrowExceptionWhenQueryComplexityExceeded() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_VIEWER")));
        when(rateLimitingConfig.getRateLimitForRole("VIEWER")).thenReturn(
                new RateLimitingInterceptor.RateLimit(60, 1800, 100)); // Low complexity limit
        when(parameters.getQuery()).thenReturn("query { ".repeat(200) + " }"); // Very long query
        when(valueOperations.get(anyString())).thenReturn(30L); // Under rate limits

        // When & Then
        assertThrows(RateLimitExceededException.class, () -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });
    }

    @Test
    void shouldAllowHigherLimitsForAdminRole() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_ADMIN")));
        when(rateLimitingConfig.getRateLimitForRole("ADMIN")).thenReturn(
                new RateLimitingInterceptor.RateLimit(300, 10000, 5000));
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");
        when(valueOperations.get(anyString())).thenReturn(250L); // Under admin limits

        // When & Then - Should not throw exception
        assertDoesNotThrow(() -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });
    }

    @Test
    void shouldSkipRateLimitingForUnauthenticatedRequests() {
        // Given
        when(authentication.isAuthenticated()).thenReturn(false);
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");

        // When & Then - Should not throw exception
        assertDoesNotThrow(() -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });

        // Verify no Redis operations were performed
        verify(valueOperations, never()).get(anyString());
    }

    @Test
    void shouldIncrementCountersAfterSuccessfulExecution() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_VIEWER")));
        when(rateLimitingConfig.getRateLimitForRole("VIEWER")).thenReturn(
                new RateLimitingInterceptor.RateLimit(60, 1800, 1000));
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");
        when(valueOperations.get(anyString())).thenReturn(30L);
        when(valueOperations.increment(anyString())).thenReturn(31L);

        // When
        var context = rateLimitingInterceptor.beginExecution(parameters, null);
        context.onDispatched(null);
        context.onCompleted(null, null);

        // Then
        verify(valueOperations, times(2)).increment(anyString()); // minute and hour counters
        verify(redisTemplate, times(2)).expire(anyString(), any());
    }

    @Test
    void shouldHandleRedisErrorsGracefully() {
        // Given
        when(authentication.getAuthorities()).thenReturn(
                List.of(new SimpleGrantedAuthority("ROLE_VIEWER")));
        when(rateLimitingConfig.getRateLimitForRole("VIEWER")).thenReturn(
                new RateLimitingInterceptor.RateLimit(60, 1800, 1000));
        when(parameters.getQuery()).thenReturn("query { exceptions { id } }");
        when(valueOperations.get(anyString())).thenThrow(new RuntimeException("Redis error"));

        // When & Then - Should not throw exception (fail open)
        assertDoesNotThrow(() -> {
            var context = rateLimitingInterceptor.beginExecution(parameters, null);
            context.onDispatched(null);
        });
    }
}