package com.arcone.biopro.exception.collector.integration;

import com.arcone.biopro.exception.collector.infrastructure.config.security.JwtService;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.test.context.ActiveProfiles;

import javax.crypto.SecretKey;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Comprehensive tests for token generation validation ensuring generated tokens
 * work with validation service
 * Requirements: 4.1, 4.2, 4.3
 */
@SpringBootTest
@ActiveProfiles("test")
@DisplayName("Token Generation Validation Tests")
class TokenGenerationValidationTest {

    @Autowired
    private JwtService jwtService;

    private final String jwtSecret = "mySecretKey1234567890123456789012345678901234567890";
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
    }

    @Nested
    @DisplayName("Generated Token Validation Tests")
    class GeneratedTokenValidationTests {

        @Test
        @DisplayName("Should validate tokens generated by Node.js script")
        void shouldValidateTokensGeneratedByNodeJsScript() throws Exception {
            // Generate token using Node.js script
            String token = generateTokenUsingNodeScript("testuser", "OPERATIONS,VIEWER");

            if (token != null && !token.isEmpty()) {
                // Validate the token using our JWT service
                Claims claims = jwtService.validateToken(token);

                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("testuser");
                assertThat(claims.get("roles")).isEqualTo(List.of("OPERATIONS", "VIEWER"));

                // Verify token is not expired
                assertThat(jwtService.isTokenExpired(claims)).isFalse();

                // Verify username extraction
                String username = jwtService.extractUsername(claims);
                assertThat(username).isEqualTo("testuser");

                // Verify authorities extraction
                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);
                assertThat(authorities).hasSize(2);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactlyInAnyOrder("ROLE_OPERATIONS", "ROLE_VIEWER");
            }
        }

        @Test
        @DisplayName("Should validate tokens generated by Python script")
        void shouldValidateTokensGeneratedByPythonScript() throws Exception {
            // Generate token using Python script
            String token = generateTokenUsingPythonScript("testuser", "OPERATIONS,VIEWER");

            if (token != null && !token.isEmpty()) {
                // Validate the token using our JWT service
                Claims claims = jwtService.validateToken(token);

                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("testuser");
                assertThat(claims.get("roles")).isEqualTo(List.of("OPERATIONS", "VIEWER"));

                // Verify token is not expired
                assertThat(jwtService.isTokenExpired(claims)).isFalse();

                // Verify username extraction
                String username = jwtService.extractUsername(claims);
                assertThat(username).isEqualTo("testuser");

                // Verify authorities extraction
                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);
                assertThat(authorities).hasSize(2);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactlyInAnyOrder("ROLE_OPERATIONS", "ROLE_VIEWER");
            }
        }

        @Test
        @DisplayName("Should validate tokens with single role")
        void shouldValidateTokensWithSingleRole() throws Exception {
            String token = generateTokenUsingNodeScript("singleuser", "ADMIN");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);

                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("singleuser");
                assertThat(claims.get("roles")).isEqualTo(List.of("ADMIN"));

                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);
                assertThat(authorities).hasSize(1);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactly("ROLE_ADMIN");
            }
        }

        @Test
        @DisplayName("Should validate tokens with multiple roles")
        void shouldValidateTokensWithMultipleRoles() throws Exception {
            String token = generateTokenUsingNodeScript("multiuser", "ADMIN,OPERATIONS,VIEWER");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);

                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("multiuser");
                assertThat(claims.get("roles")).isEqualTo(List.of("ADMIN", "OPERATIONS", "VIEWER"));

                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);
                assertThat(authorities).hasSize(3);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactlyInAnyOrder("ROLE_ADMIN", "ROLE_OPERATIONS", "ROLE_VIEWER");
            }
        }

        @Test
        @DisplayName("Should validate default tokens generated by scripts")
        void shouldValidateDefaultTokensGeneratedByScripts() throws Exception {
            // Generate default token (no parameters)
            String nodeToken = generateTokenUsingNodeScript(null, null);
            String pythonToken = generateTokenUsingPythonScript(null, null);

            if (nodeToken != null && !nodeToken.isEmpty()) {
                Claims claims = jwtService.validateToken(nodeToken);
                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("test-user");
                assertThat(claims.get("roles")).isEqualTo(List.of("ADMIN"));
            }

            if (pythonToken != null && !pythonToken.isEmpty()) {
                Claims claims = jwtService.validateToken(pythonToken);
                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("test-user");
                assertThat(claims.get("roles")).isEqualTo(List.of("ADMIN"));
            }
        }
    }

    @Nested
    @DisplayName("Token Expiration Handling Tests")
    class TokenExpirationHandlingTests {

        @Test
        @DisplayName("Should handle token expiration correctly")
        void shouldHandleTokenExpirationCorrectly() throws Exception {
            // Generate a token that should be valid for 1 hour
            String token = generateTokenUsingNodeScript("exptest", "OPERATIONS");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);

                // Token should not be expired immediately
                assertThat(jwtService.isTokenExpired(claims)).isFalse();

                // Check expiration time is approximately 1 hour from now
                Date expiration = claims.getExpiration();
                Date now = new Date();
                long timeDiff = expiration.getTime() - now.getTime();
                long hourInMs = TimeUnit.HOURS.toMillis(1);

                // Should be close to 1 hour (within 5 minutes tolerance)
                assertThat(timeDiff).isBetween(hourInMs - TimeUnit.MINUTES.toMillis(5),
                        hourInMs + TimeUnit.MINUTES.toMillis(5));
            }
        }

        @Test
        @DisplayName("Should validate token structure and claims")
        void shouldValidateTokenStructureAndClaims() throws Exception {
            String token = generateTokenUsingNodeScript("structtest", "OPERATIONS");

            if (token != null && !token.isEmpty()) {
                // Verify token has correct structure (3 parts separated by dots)
                String[] parts = token.split("\\.");
                assertThat(parts).hasSize(3);

                Claims claims = jwtService.validateToken(token);

                // Verify required claims are present
                assertThat(claims.getSubject()).isNotNull();
                assertThat(claims.getIssuedAt()).isNotNull();
                assertThat(claims.getExpiration()).isNotNull();
                assertThat(claims.get("roles")).isNotNull();

                // Verify issued at is before expiration
                assertThat(claims.getIssuedAt()).isBefore(claims.getExpiration());

                // Verify issued at is recent (within last minute)
                Date now = new Date();
                long timeDiff = now.getTime() - claims.getIssuedAt().getTime();
                assertThat(timeDiff).isLessThan(TimeUnit.MINUTES.toMillis(1));
            }
        }
    }

    @Nested
    @DisplayName("Different User Roles and Permissions Tests")
    class DifferentUserRolesAndPermissionsTests {

        @Test
        @DisplayName("Should validate ADMIN role tokens")
        void shouldValidateAdminRoleTokens() throws Exception {
            String token = generateTokenUsingNodeScript("admin", "ADMIN");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);
                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);

                assertThat(authorities).hasSize(1);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactly("ROLE_ADMIN");
            }
        }

        @Test
        @DisplayName("Should validate OPERATIONS role tokens")
        void shouldValidateOperationsRoleTokens() throws Exception {
            String token = generateTokenUsingNodeScript("operator", "OPERATIONS");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);
                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);

                assertThat(authorities).hasSize(1);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactly("ROLE_OPERATIONS");
            }
        }

        @Test
        @DisplayName("Should validate VIEWER role tokens")
        void shouldValidateViewerRoleTokens() throws Exception {
            String token = generateTokenUsingNodeScript("viewer", "VIEWER");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);
                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);

                assertThat(authorities).hasSize(1);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactly("ROLE_VIEWER");
            }
        }

        @Test
        @DisplayName("Should validate mixed case role tokens")
        void shouldValidateMixedCaseRoleTokens() throws Exception {
            String token = generateTokenUsingNodeScript("mixeduser", "admin,operations,viewer");

            if (token != null && !token.isEmpty()) {
                Claims claims = jwtService.validateToken(token);
                Collection<GrantedAuthority> authorities = jwtService.extractAuthorities(claims);

                // The system should normalize roles to uppercase
                assertThat(authorities).hasSize(3);
                assertThat(authorities.stream().map(GrantedAuthority::getAuthority))
                        .containsExactlyInAnyOrder("ROLE_ADMIN", "ROLE_OPERATIONS", "ROLE_VIEWER");
            }
        }
    }

    @Nested
    @DisplayName("Algorithm and Secret Consistency Tests")
    class AlgorithmAndSecretConsistencyTests {

        @Test
        @DisplayName("Should validate algorithm consistency between generation and validation")
        void shouldValidateAlgorithmConsistencyBetweenGenerationAndValidation() throws Exception {
            String token = generateTokenUsingNodeScript("algtest", "OPERATIONS");

            if (token != null && !token.isEmpty()) {
                // Manually parse the token to verify algorithm
                String[] parts = token.split("\\.");
                String headerJson = new String(java.util.Base64.getUrlDecoder().decode(parts[0]));

                // Verify the header contains HS256 algorithm
                assertThat(headerJson).contains("\"alg\":\"HS256\"");
                assertThat(headerJson).contains("\"typ\":\"JWT\"");

                // Verify the token validates successfully with our service
                Claims claims = jwtService.validateToken(token);
                assertThat(claims).isNotNull();
            }
        }

        @Test
        @DisplayName("Should validate secret key consistency")
        void shouldValidateSecretKeyConsistency() throws Exception {
            String token = generateTokenUsingNodeScript("secrettest", "OPERATIONS");

            if (token != null && !token.isEmpty()) {
                // The fact that validation succeeds proves secret consistency
                Claims claims = jwtService.validateToken(token);
                assertThat(claims).isNotNull();
                assertThat(claims.getSubject()).isEqualTo("secrettest");

                // Additionally, verify we can create a token with the same secret that
                // validates
                String javaToken = createTokenWithSameSecret("secrettest", List.of("OPERATIONS"));
                Claims javaClaims = jwtService.validateToken(javaToken);
                assertThat(javaClaims).isNotNull();
                assertThat(javaClaims.getSubject()).isEqualTo("secrettest");
            }
        }

        @Test
        @DisplayName("Should reject tokens created with different secrets")
        void shouldRejectTokensCreatedWithDifferentSecrets() throws Exception {
            // Create a token with a different secret
            String wrongSecret = "differentSecret123456789012345678901234567890";
            SecretKey wrongKey = Keys.hmacShaKeyFor(wrongSecret.getBytes(StandardCharsets.UTF_8));

            String tokenWithWrongSecret = Jwts.builder()
                    .subject("wrongsecret")
                    .claim("roles", List.of("OPERATIONS"))
                    .issuedAt(new Date())
                    .expiration(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))
                    .signWith(wrongKey)
                    .compact();

            // This should fail validation
            assertThatThrownBy(() -> jwtService.validateToken(tokenWithWrongSecret))
                    .isInstanceOf(JwtService.InvalidJwtTokenException.class)
                    .hasMessageContaining("JWT token signature is invalid");
        }

        @Test
        @DisplayName("Should validate token signature integrity")
        void shouldValidateTokenSignatureIntegrity() throws Exception {
            String token = generateTokenUsingNodeScript("integritytest", "OPERATIONS");

            if (token != null && !token.isEmpty()) {
                // Valid token should validate successfully
                Claims claims = jwtService.validateToken(token);
                assertThat(claims).isNotNull();

                // Tampered token should fail validation
                String[] parts = token.split("\\.");
                String tamperedToken = parts[0] + "." + parts[1] + ".tampered_signature";

                assertThatThrownBy(() -> jwtService.validateToken(tamperedToken))
                        .isInstanceOf(JwtService.InvalidJwtTokenException.class);
            }
        }
}

@Nested
@DisplayName("Cross-Platform Token Compatibility Tests")
class CrossPlatformTokenCompatibilityTests {

@Test
        @DisplayName("Should validate tokens are compatible between Node.js and Python scripts")
        void shouldValidateTokensAreCompatibleBetweenNodeJsAndPythonScripts() throws Exception {
String nodeToken = generateTokenUsingNodeScript("crosstest", "OPERATIONS");
            String pythonToken = generateTokenUsingPythonScript("crosstest", "OPERATIONS");
            
            if (nodeToken != null && !nodeToken.isEmpty() && pythonToken != null && !pythonToken.isEmpty()) {
                // Both tokens should validate successfully
                Claims nodeClaims = jwtService.validateToken(nodeToken);
                Claims pythonClaims = jwtService.validateToken(pythonToken);
                
                assertThat(nodeClaims).isNotNull();
                assertThat(pythonClaims).isNotNull();
                
                // Both should have the same subject and roles
                assertThat(nodeClaims.getSubject()).isEqualTo("crosstest");
                assertThat(pythonClaims.getSubject()).isEqualTo("crosstest");
                assertThat(nodeClaims.get("roles")).isEqualTo(List.of("OPERATIONS"));
                assertThat(pythonClaims.get("roles")).isEqualTo(List.of("OPERATIONS"));
            }
        }

        @Test
        @DisplayName("Should validate Java-generated tokens work with same validation service")
        void shouldValidateJavaGeneratedTokensWorkWithSameValidationService() throws Exception {
            // Create token using Java (same as the service uses)
            String javaToken = createTokenWithSameSecret("javatest", List.of("OPERATIONS"));
            
            // Validate using the same service
            Claims claims = jwtService.validateToken(javaToken);
            assertThat(claims).isNotNull();
            assertThat(claims.getSubject()).isEqualTo("javatest");
            assertThat(claims.get("roles")).isEqualTo(List.of("OPERATIONS"));
            
            // Verify complete validation
            assertThat(jwtService.isTokenValid(javaToken)).isTrue();
        }
    }

    // Helper methods for generating tokens using external scripts
    private String generateTokenUsingNodeScript(String username, String roles) {
        try {
            ProcessBuilder pb = new ProcessBuilder();
            if (username != null && roles != null) {
                pb.command("node", "generate-jwt.js", username, roles);
            } else {
                pb.command("node", "generate-jwt.js");
            }
            
            Process process = pb.start();
            
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                String line;
                String token = null;
                while ((line = reader.readLine()) != null) {
                    // Look for the raw token line (last line of output)
                    if (!line.startsWith("üîë") && !line.startsWith("‚îÅ") && !line.startsWith("üë§") && 
                        !line.startsWith("üõ°Ô∏è") && !line.startsWith("‚è∞") && !line.startsWith("üìã") && 
                        !line.startsWith("üîó") && !line.startsWith("Bearer") && !line.trim().isEmpty()) {
                        token = line.trim();
                    }
                }
                
                process.waitFor();
                return token;
            }
        } catch (IOException | InterruptedException e) {
            // Script execution failed, skip the test
            return null;
        }
    }

    private String generateTokenUsingPythonScript(String username, String roles) {
        try {
            ProcessBuilder pb = new ProcessBuilder();
            if (username != null && roles != null) {
                pb.command("python3", "generate-jwt.py", username, roles);
            } else {
                pb.command("python3", "generate-jwt.py");
            }
            
            Process process = pb.start();
            
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) {
                String line;
                String token = null;
                while ((line = reader.readLine()) != null) {
                    // Look for the raw token line (last line of output)
                    if (!line.startsWith("üîë") && !line.startsWith("‚îÅ") && !line.startsWith("üë§") && 
                        !line.startsWith("üõ°Ô∏è") && !line.startsWith("‚è∞") && !line.startsWith("üìã") && 
                        !line.startsWith("üîó") && !line.startsWith("Bearer") && !line.trim().isEmpty()) {
                        token = line.trim();
                    }
                }
                
                process.waitFor();
                return token;
            }
        } catch (IOException | InterruptedException e) {
            // Script execution failed, skip the test
            return null;
        }
    }

    private String createTokenWithSameSecret(String username, List<String> roles) {
        return Jwts.builder()
                .subject(username)
                .claim("roles", roles)
                .issuedAt(new Date())
                .expiration(Date.from(Instant.now().plus(1, ChronoUnit.HOURS)))
                .signWith(secretKey)
                .compact();
    }
}